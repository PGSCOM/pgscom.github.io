---
import Layout from '../layouts/Layout.astro';
import './styles.css';
import { Image } from 'astro:assets';
import pgscom from '../assets/pgscom.png';
import minimal1 from '../assets/minimal1.svg';
import customShape from '../assets/custom-shape.svg';
import minimal3 from '../assets/minimal3.svg';
---

<Layout>
	<main class="main-container">
		<div class="particles">
			<Image src={minimal1} alt="" class="particle particle-1" width={100} height={100} />
			<Image src={customShape} alt="" class="particle particle-2" width={100} height={100} />
			<Image src={minimal3} alt="" class="particle particle-3" width={100} height={100} />
			<Image src={minimal1} alt="" class="particle particle-4" width={100} height={100} />
			<Image src={customShape} alt="" class="particle particle-5" width={100} height={100} />
			<Image src={minimal3} alt="" class="particle particle-6" width={100} height={100} />
		</div>
		<div class="content">
			<h1 id="animated-text" class="logo-text">PGSCOM</h1>
		</div>
		<div class="image-container">
			<Image src={pgscom} alt="PGSCOM Character" class="fotopgs" width={2617} height={3490} loading="eager" />
		</div>
	</main>

	<script is:inline defer>
		document.addEventListener('DOMContentLoaded', async () => {
			const animatedText = document.getElementById('animated-text');
			
			// Array de fuentes disponibles
			const fonts = [
				'Allerta Stencil',
				'Bungee Inline',
				'Chakra Petch',
				'Kranky',
				'Limelight',
				'Meow Script',
				'Modak',
				'Monoton',
				'Offside',
				'Pacifico',
				'Permanent Marker',
				'Rampart One',
				'Solway',
				'Tapestry',
				'Tiny5',
			];
			
			// Factor de escala para cada fuente para mantener tamaño visual consistente
			const fontSizeFactors = {
				'Allerta Stencil': 1.0,
				'Bungee Inline': 0.9,
				'Chakra Petch': 1,
				'Kranky': 1.0,
				'Limelight': 0.95,
				'Meow Script': 0.85,
				'Modak': 1.0,
				'Monoton': 0.8,
				'Offside': 1.1,
				'Pacifico': 0.8,
				'Permanent Marker': 1.0,
				'Rampart One': 0.8,
				'Solway': 1.15,
				'Tapestry': 1.05,
				'Tiny5': 1.2,
			};
			
			// Base font size in viewport width units
			const baseFontSize = 7; // corresponde al 7cqw en CSS
			const delayfont = 5000;
			
			// Variables de duración de transición
			const transitionDuration = {
				fadeOut: 600,    // Duración del fade-out en ms
				fadeIn: 800,     // Duración del fade-in en ms
				get total() { return this.fadeOut + this.fadeIn; } // Duración total
			};
			
			let currentFontIndex = 0;
			let fontsLoaded = false;

			// Función para precargar todas las fuentes
			async function preloadFonts() {
				console.log('Precargando fuentes...');
				
				try {
					// Usar Font Loading API si está disponible
					if ('fonts' in document) {
						const fontPromises = fonts.map(fontName => {
							// Usar peso Medium (500) para Solway y Chakra Petch
							// Usar peso Regular (400) para Modak, Monoton
							// Bold para el resto
							let fontWeight = 'bold';
							if (fontName === 'Solway' || fontName === 'Chakra Petch') {
								fontWeight = '500';
							} else if (fontName === 'Modak' || fontName === 'Monoton') {
								fontWeight = '400';
							}
							return document.fonts.load(`${fontWeight} 5rem "${fontName}"`);
						});
						
						await Promise.all(fontPromises);
						console.log('Todas las fuentes cargadas via Font Loading API');
					} else {
						// Fallback: crear elementos invisibles para forzar la carga
						const testContainer = document.createElement('div');
						testContainer.style.position = 'absolute';
						testContainer.style.visibility = 'hidden';
						testContainer.style.fontSize = '5rem';
						testContainer.style.fontWeight = 'bold';
						document.body.appendChild(testContainer);
						
						const loadPromises = fonts.map(fontName => {
							return new Promise((resolve) => {
								const testElement = document.createElement('span');
								testElement.textContent = 'PGSCOM';
								testElement.style.fontFamily = `"${fontName}", cursive`;
								// Aplicar peso específico para cada fuente
								if (fontName === 'Solway' || fontName === 'Chakra Petch') {
									testElement.style.fontWeight = '500';
								} else if (fontName === 'Modak' || fontName === 'Monoton') {
									testElement.style.fontWeight = '400';
								} else {
									testElement.style.fontWeight = 'bold';
								}
								testContainer.appendChild(testElement);
								
								// Esperar un poco para asegurar la carga
								setTimeout(() => {
									testContainer.removeChild(testElement);
									resolve();
								}, 100);
							});
						});
						
						await Promise.all(loadPromises);
						document.body.removeChild(testContainer);
						console.log('Todas las fuentes cargadas via fallback');
					}
					
					fontsLoaded = true;
				} catch (error) {
					console.log('Error cargando fuentes:', error);
					fontsLoaded = true; // Continuar de todos modos
				}
			}

			function changeFontFamily() {
				if (!fontsLoaded) return;
				
				// Usamos la referencia global
				const currentEl = window.animatedText;
				
				// Iniciar fade-out con blur
				currentEl.classList.add('fade-out');
				
				// Esperar a que se complete el fade-out antes de cambiar la fuente
				setTimeout(() => {
					// Cambiar a la siguiente fuente
					currentFontIndex = (currentFontIndex + 1) % fonts.length;
					const currentFont = fonts[currentFontIndex];
					
					// Cambiar la fuente mientras está invisible
					currentEl.style.fontFamily = `"${currentFont}", cursive`;
					
					// Aplicar peso específico para cada tipo de fuente
					if (currentFont === 'Solway' || currentFont === 'Chakra Petch') {
						currentEl.style.fontWeight = '500';
					} else if (currentFont === 'Modak' || currentFont === 'Monoton') {
						currentEl.style.fontWeight = '400';
					} else {
						currentEl.style.fontWeight = 'bold';
					}
					
					// Ajustar el tamaño según el factor de la fuente
					const factor = fontSizeFactors[currentFont] || 1.0;
					const newSize = baseFontSize * factor;
					currentEl.style.fontSize = `${newSize}cqw`;
					
					console.log(`Font changed to: ${currentFont} (weight: ${currentEl.style.fontWeight}, factor: ${factor}, size: ${newSize}cqw)`);
					
					// Iniciar fade-in
					currentEl.classList.remove('fade-out');
					currentEl.classList.add('fade-in');
					
					// Remover la clase de fade-in después de completar la animación
					setTimeout(() => {
						currentEl.classList.remove('fade-in');
					}, transitionDuration.fadeIn);
					
				}, transitionDuration.fadeOut);
			}

			// Inicializar con la primera fuente y estado de carga
			const initialFont = fonts[0];
			animatedText.style.fontFamily = `"${initialFont}", cursive`;
			if (initialFont === 'Solway' || initialFont === 'Chakra Petch') {
				animatedText.style.fontWeight = '500';
			} else if (initialFont === 'Modak' || initialFont === 'Monoton') {
				animatedText.style.fontWeight = '400';
			} else {
				animatedText.style.fontWeight = 'bold';
			}
			
			// Aplicar el factor de escala inicial
			const initialFactor = fontSizeFactors[initialFont] || 1.0;
			animatedText.style.fontSize = `${baseFontSize * initialFactor}cqw`;
			
			animatedText.classList.add('loading');
			
			// Precargar todas las fuentes
			await preloadFonts();
			
			// Remover estado de carga y comenzar animación
			animatedText.classList.remove('loading');
			animatedText.classList.add('loaded');
			
			// Comenzar la animación solo después de cargar las fuentes
			console.log('Iniciando animación de fuentes...');
			
			// Referencia al elemento para que pueda ser actualizado en changeFontFamily
			window.animatedText = animatedText;
			
			setInterval(changeFontFamily, delayfont);
		});
	</script>
</Layout>
